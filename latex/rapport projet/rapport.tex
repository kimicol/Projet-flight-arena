\documentclass[12pt, titlepage]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
%\usepackage{Times}

%Mise en page

\usepackage[top=2cm, bottom=2.5cm, left=4cm , right=3cm]{geometry}
\usepackage{setspace}
%\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

%Caractères spéciaux

\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}

\usepackage{eurosym} %insertion signe euro
\usepackage{graphicx} %insertion d'images
\usepackage{fancyhdr} %en-tete et pied de page

\title{\bsc{rapport de projet}\\Projet flight arena}
\author{mr cube :\\
Vincent \bsc{Rospini-Clerici},\\
Guillaume \bsc{Rebut}\\
chef de projet : Arthur \bsc{Remaud}}
\date{16 juin 2015}

\pagestyle{fancy}
\fancyhead{}
\fancyfoot{\thepage}
\lhead{\leftmark}
\rhead{Projet Flight Arena}
\lfoot{}
\rfoot{}


\begin{document}
\begin{spacing}{1.5}

\maketitle

\renewcommand{\contentsname}{Sommaire}
\renewcommand{\chaptername}{Partie}

\tableofcontents
\addcontentsline{toc}{section}{Introduction}


\newpage
\section*{Introduction}
Le groupe mr cube, composé de Guillaume Rebut, Vincent Rospini Clerici et Arthur Remaud, est fier de vous présenter son projet : \textit{flight arena}.\\

Ce projet est réalisé dans le cadre  du projet de première année de l'école \bsc{epita}. C’est un projet libre par groupe de quatre. Le but est de nous apprendre à travailler en équipe, tout en gérant un projet du début à la fin de sa conception. Nous avions pour ce projet l'obligation d'utiliser les langages \textit{Caml} ou {C\#}, avec le moteur Unity pour faire le jeu. Le projet comporte obligatoirement un cahier des charges, et des rapports de projet étalés sur trois soutenances. Ne voulant pas faire un jeu de combat ou de plateforme classique, le groupe est parti de l’idée de créer un jeu semblable à un de ceux de la fameuse saga de "Starfox". Nous avons donc choisi de faire un jeu de vaisseau dirigé à la troisième personne dans lequel le but est d'éliminer ses ennemis.\\

Notre groupe contenait au départ un autre membre, Nikolas Miletic. Celui-ci est parti en S1\# au cours du mois de janvier. Nous avons réparti les tâches de cette manière : Vincent s'est occupé principalement des graphismes et du site internet, Guillaume du gameplay et de l’interface utilisateur, et Arthur du code du jeu et des menus.\\

\newpage
\section{Objectifs du projet}

L'idée d'un projet de groupe amène à envisager une multitude de caractéristiques à prendre en compte, aussi bien dans le domaine de l'enseignement que dans celui du travail. Il permet notamment de faire face à des situations d'autonomie, qui s'avèrent nécessaires à son avancement. Il s'agit de se montrer indépendant, et de réaliser son travail individuel essentiel à l'avancement du projet. Le temps de réalisation est tout aussi important, puisqu'il faut également prendre en compte le fait que le temps imparti était de six mois, ce qui laisse à penser que cette idée de réalisation n'est absolument pas à prendre à la légère. Il fallait, au contraire, être conscient de la quantité de réflexion et de travail requise à l'aboutissement du projet au terme de ce semestre.\\

Un tel projet permet de concrétiser et de mettre en évidence un exemple des cas concrets comprenant de la programmation pour le développement de logiciels (ici, d’un jeu). Nous aurons donc l'opportunité de mettre en pratique ce que l’on a retenu dans le futur.\\

Même s'il s'agit d'acquérir de l'expérience vis-à-vis de soi, et de comprendre ce système de fonctionnement de manière individuelle et autonome, il ne faut pas négliger le fait que ce projet a été réalisé en groupe. Dans le monde du travail, la coopération est un apport nécessaire à l'aboutissement de projets. La répartition des tâches s’est effectuée suite à une réflexion sur laquelle il a fallu faire appel aux compétences propres à chaque membre. Il s'agit d'optimiser le travail en le répartissant, et de progresser de la manière la plus efficace possible.\\

La communication est également essentielle. Il nous a fallu adapter la quantité de travail en fonction des capacités de chacun, toujours avoir une longueur d'avance sur l'avancement du projet visé et si possible, prendre de l'avance lorsque cela était possible. Il est question d'acquisition d'expérience par une méthode qui n'est pas forcément accessible à chacun, et le cadre scolaire de l'EPITA nous permet de nous mettre en situation réelle afin de pouvoir surmonter les différentes difficultés que nous rencontrerons lors de nos projets futurs.\\


\newpage
\section{Graphismes et son}

\subsection{Graphismes}

Après le visionnage de différents tutoriels Blender sur la modélisation d'objets 3D, Vincent a créé le premier vaisseau qui sera utilisé par le joueur dans le jeu. C'était la première fois qu'il utilisait le logiciel Blender. Il s'est servi principalement de la fonction extrude en partant d'un simple cube pour parvenir à modéliser ce qu'il souhaitait. Cette fonction permet en effet d'avoir un vaisseau en un seul objet plus aisément qu'en utilisant l'ajout de \textit{mesh}. Par exemple, en coupant les solides en différentes parties grâce à l'outil \textit{knife}, cela a permis d'extraire la forme basique des ailes à partir du corps principal du vaisseau.\\

Il a aussi utilisé le modifier \textit{mirror} qui est très important. Il permet de créer une image de l’objet par rapport à un axe. Cela permet au vaisseau d'être parfaitement symétrique en ne créant qu’une partie de celui-ci.\\

Vincent a également utilisé le modifier \textit{subdivision surface} pour créer des surfaces de subdivision, c’est-à-dire découper les faces de l’objet en plusieurs afin de lisser l’objet. Ce \textit{modifier} appliqué sur l’ensemble du vaisseau lui donne cet aspect moins carré et c’était exactement ce qu’il fallait pour aller avec les graphismes du jeu. Une fois la modélisation terminée, il a fallu également texturer toutes les faces du vaisseau afin d'avoir un beau rendu dans le jeu.\\

Pour se faire, il a fallu se servir de l'outil \textit{UV Mapping} qu'offre Blender. Il s'agit de sélectionner toutes les arrêtes du vaisseau et de les déplier sur un plan en deux dimensions. Le logiciel Photoshop permet ensuite de remplir les différentes faces avec les couleurs et textures voulues. Le vaisseau a été texturé entièrement en rouge et noir avec des dégradés de couleur.\\
De nombreux problèmes ont été rencontrés lors de la création de textures pour le vaisseau.\\

Au moment de passer l’\textit{Uv Mapping} sur Blender pour le premier vaisseau afin de lui ajouter ses textures, nous nous sommes rendu compte que Blender affichait le vaisseau avec des problèmes de symétrie. C’était en réalité dû au modifier \textit{bevel} qui était censé entre autre biseauter les faces du vaisseau. En l’enlevant, Vincent a réalisé que le vaisseau rendait bien mieux avec le modifier \textit{Subdivision Surface} qu’avec le modifier \textit{Bevel} et que les problèmes de symétrie disparaissaient.\\

Un autre problème est survenu lors du dépliage des faces du vaisseau par l’\textit{Uv mapping}.
Le vaisseau ayant plus de trois cent faces, nous avons décidé de découper l’\textit{Uv mapping} par patrons, mais cette tâche s’est révélée très complexe et lorsque nous avons déplié le patron du vaisseau, les faces étaient méconnaissables et toutes empilées les unes sur les autres. Il a donc fallu opter pour une autre méthode : Sélectionner toutes les faces du vaisseau, puis les déplier toutes indépendamment. Finalement il a fallu repérer toutes les faces et les regrouper par endroit du vaisseau (ailes, avant, etc...) afin de ne pas se perdre au moment de texturer toutes les faces.\\

Voilà comment le tout premier vaisseau a été réalisé. Dans le souci d'ajouter du contenu, deux nouveaux vaisseaux ont été créés de la même manière sur Blender et texturés sur Photoshop. Il s'agit tout d'abord d'un vaisseau qui ferait penser à un jet militaire tout droit venu du futur. Sa texture de base est comparable aux tâches marrons, beiges et vertes d’un apparat militaire. L'autre est inspiré du P40, un avion militaire américain utilisé durant la seconde guerre mondiale et auquel Vincent a rajouté des nacelles de missiles et des réacteurs pour lui donner un air à la fois futuriste et ancien. Une gueule de requin est dessinée sur l’avant du vaisseau comme sur les dessins sur la carlingue du P40 de l’époque où la gueule de prédateur permettait de rendre l’avion terrifiant pour l’ennemi.
Des textures différentes sont disponibles pour chaque vaisseau et sont sélectionnables dans le menu au moment de la sélection du vaisseau.\\

Les flammes sortant des réacteurs des vaisseaux ont été rajoutées par le biais de la création de particules qu'offre Unity. Tout d'abord, Vincent a rajouté des éléments de particules pour créer juste des flammes sortant des réacteurs, mais le groupe s'est mis d'accord pour que les réacteurs laissent une trainée après le passage du vaisseau. Cette trainée de flammes a été inspirée d’un jeu peu connu mais nous tenant à cœur, du nom de "New York Race". \\

Les trainées laissées par le réacteur sont différentes selon le vaisseau. Par exemple, l'avion laisse une trainée noire de fumée, tandis que le vaisseau rouge et noir laisse une trainée variant du bleu à l’orange. De cette façon, les vaisseaux adverses sont plus faciles à reconnaitre parmi les différents éléments de la carte. \\

Lors de la création de ces particules, nous avons rencontré un problème. Les particules étant contenues dans le \textit{gameobject} du vaisseau, les flammes se déplaçaient en même temps que le vaisseau se déplaçait, au lieu de simplement suivre sa trajectoire. Cela donnait alors l’impression que les flammes du réacteur étaient rattachées au vaisseau. Après quelques recherches sur internet nous avons trouvé le paramètre permettant de régler le problème. Il s'agissait de définir l'espace de simulation de la particule au niveau de son environnement et non au niveau de l'objet. Ainsi les particules évoluent librement dans l’espace sans suivre le vaisseau et le résultat est très satisfaisant.\\

La création de l’explosion lors de la destruction du vaisseau a été faite elle aussi sur Unity grâce à l’éditeur de particules. Elle se compose de plusieurs particules. Certaines particules ont été utilisees pour faire de la fumée, d'autres des débris et encore d'autres pour créer des étincelles. Les textures des particules ont été trouvées sur l’\textit{Asset store} et les explications relatives proviennent d'un tutoriel pour créer des explosions aériennes.\\


\subsection{Son}

Nous avons finalement eu le temps et la patience de créer une musique originale pour le jeu. Vincent a contacté un ami à lui qui fait des études musicales afin de savoir s'il était possible de créer des musiques en coopération avec lui. La réponse étant positive, deux musiques ont été créées à ce jour par notre ami assisté par Vincent par le biais du logiciel Logic Pro. \\
Nous souhaitions des musiques électroniques qui soient futuristes avec un tempo lent et régulier. De ce fait, l'ambiance en ressortant reste angoissante et la peur de voir un ennemi surgir de derrière un bâtiment de la carte ou de se faire surprendre par derrière est présente.\\

"There's something beyond" et "Vincighilan", les deux musiques, ont été ajoutées sur Unity et sont écoutables dès lors qu'un joueur entre dans la partie. \\

La musique qui se lance dès l’entrée sur le menu du jeu vient du film "Captain America" et c’est le thème principal. L’équipe s’étant mise d’accord pour avoir une musique qui fait tout de suite penser aux fameux films de Star Wars dès l’arrivée sur le menu, ce thème nous semblait coller parfaitement à nos attentes. \\

Concernant les sons du jeu, nous avons implémenté dans le jeu tous les sons nécessaires à rendre un jeu dynamique. Il y a par exemple le son des projectiles tirés par le vaisseau qui est un son pris sur le jeu "Space Cadet Pinball". Egalement le bruit de l’explosion du vaisseau qui est un son assez fort et le bruit des réacteurs des différents vaisseaux. \\


\newpage
\section{Contrôles du vaisseau}

Nous avons implémentes les contrôles du vaisseau des la première séance de travaille.. En effet nous avions besoin de déplacements pour faire par la suite pour faire la première carte du jeu, afin d'espacer correctement les obstacles pour que le vaisseau puisse faire des man\oe uvres, et des tirs pour pouvoir gérer les dégâts et la mort des vaisseaux.\\

\subsection{Déplacement}

Dans un premier temps, Arthur a codé les déplacements des vaisseaux. Pour prendre les touches que le joueur entre, on utilise la fonction \textit{Input.GetKey()} de Unity.\\

Les vaisseaux ont trois types de mouvements : le roulis, rotation du vaisseau selon l'axe longitudinale, le tangage , rotation du vaisseau sur son axe transversal, et le lacet, rotation du vaisseau selon l'axe vertical. Les vitesses de rotations s'inspirent des valeurs des avions : le tangage est plus rapide que le roulis qui est bien plus rapide que le lacet. Nous avons aussi choisi de prendre ces valeurs pour des raisons de gameplay. En effet, il est plus facile de tourner avec le lacet plutôt que d'utiliser la combinaison tangage plus roulis. Il est donc logique de rendre cette dernière man\oe uvre plus rapide en exécution pour récompenser les joueurs les plus talentueux. Nous avons placé la caméra de manière à inciter le joueur à utiliser cette dernière man\oe uvre : le vaisseau n'est pas représenté au milieu de l'écran mais en bas pour donner plus de visibilité. Toujours dans une optique de réalisme et de difficulté, le vaisseau a de l'inertie  lorsqu'il avance ainsi que sur les trois types de mouvements. Enfin, il est impossible de reculer avec le vaisseau. Le joueur doit faire demi-tour en faisant une boucle.\\

Le vaisseau est entièrement contrôlable au clavier. Les touches directionnelles représentent un joystick d'avion et permettent le tangage (flèche du haut pour piquer et flèche du bas pour "monter") et le roulis (flèche gauche pour une rotation anti-horaire et flèche droite pour une rotation horaire). La touche W permet accélération et les touches A et D permettent de tourner respectivement à gauche et à droite grâce au lacet.\\

Le vaisseau doit donc avancer et tourner sur lui-même pour parcourir les niveaux. Pour cela, nous utilisions tout d'abord respectivement les fonctions \textit{transform.Translate()} et \textit{transform.Rotate()}. L'inertie du vaisseau était gérée par une variable de déplacement qui augmentait à force d'appuyer sur la touche d'accélération, et diminuait dans le cas contraire.\\

Cependant, les mouvements n'étaient pas très réalistes et il nous avait été suggéré à la fin de la première soutenance d'utiliser les quaternions que propose Unity pour donner une meilleure inertie et donc des déplacements plus crédibles. Cela fut rajouté dans la semaine qui suivit, grâce aux nombreux tutoriels et documentations trouvables sur internet.\\

Les quaternions sont utilisés en mathématiques dans la géométrie dans l'espace (en trois dimensions), un peu comme les complexes sont utilisés dans le plan (en deux dimensions donc). Ils sont notamment utiles tout ce qui est rotations des objets. De plus, Unity possèdent plusieurs fonctions qui permettent de simplifier leur utilisation. Dans un objet Unity, il y a un quaternion qui contient la rotation de l'objet, appelé \textit{transform.rotation}. On modifie donc cette valeur avec la fonction \textit{Quaternion.Slerp()} qui permet de passer d'une rotation à une autre. Comme quaternion cible, on prend la rotation de l'objet que l'on aditionne à un quaternion auquel on a modifié les valeurs selon les entrées du joueur.\\

Le problème qui se posa avec les quaternions fut en rapport avec les collisions. En effet avant de les ajouter, nous avions mis le \textit{rigidbody} des vaisseaux, soit l'élément qui gère les collisions avec les rebonds et l'inertie engendrée, à zéro. Dans le cas contraire, dès que le vaisseau touchait un obstacle, il rebondissait et partait en vrille, sans que le joueur ne puisse y remédier.\\

\subsection{Tirs}

Le joueur peut tirer grâce à la touche espace, elle aussi détectée par la fonction \textit{Input.GetKey()}. Unity instancie alors une balle qui est stockée dans un prefab grâce à la fonction qui s'appelle, logiquement, \textit{Instantiate()}. La balle part droit devant elle si elle ne touche aucun obstacle et disparait d'elle-même au bout de trois secondes avec la fonction \textit{DestroyObject()}, ce qui lui laisse le temps de traverser la carte, afin qu'il n 'y ait pas trop d'objets en même temps à gérer par Unity, ce qui pourrait ralentir le jeu.\\

La balle contient un \textit{trigger}, ce qui veut dire qu'elle déclenche un événement lorsqu'elle rencontre un objet qui contient un détecteur particulier. En effet, si un vaisseau détecte une collision avec une balle grâce à la fonction \textit{OnTriggerEnter()}, alors la balle est détruite et le vaisseau perd un point de vie. De plus, si le vaisseau n'a plus de vie, il est alors détruit avec une animation d'explosion. Des sons ont été intégrés à chaque étape : au tir, à la collision et à l'explosion.\\

\newpage
\section{Gameplay}

\newpage
\section{Création de niveaux}

\subsection{Environnement de la carte}
La première chose à faire lorsque l’on créé une nouvelle scène dans Unity est de s’occuper de l’environnement. Cela permet d’avoir une vision globale de ce qui est nécessaire à la carte avant de commencer à rajouter des bâtiments ou autres.\\

Tout d’abord, nous avons utilisé la méthode la plus répandue pour ajouter un "faux" ciel dans Unity. C’est-à-dire, en utilisant \textit{l'asset skybox} de Unity qui permet en quelque sorte de créer une boite texturée ressemblant parfaitement à un ciel. Nous voulions au moins une carte de jour, et une de nuit. Nous avons donc des \textit{skybox} différentes pour chaque scène. La lumière quant à elle est gérée avec un \textit{directional light} créé par l'\textit{asset} de base et est donc modifiable aisément.\\

Les textures du sol ont été créées en utilisant l'outil \textit{brush}(pinceau). Cela permet de peindre le sol pour reproduire de l’herbe, du béton ou des graviers de façon réaliste par exemple. Pour créer des montagnes nous avons utilisé l’outil permettant de choisir l’altitude du sol et recouvert ses flancs avec une texture rocailleuse.\\

\subsection{Création de bâtiments}

Nous avions créé une dizaine de bâtiments différents et entièrement texturés pour les besoins de la première carte. Ces bâtiments ont été créés sur Blender et texturés sur Photoshop de la même façon que les vaisseaux. Ils avaient tous des formes et des hauteurs différentes, mais restaient assez basiques car ils nous permettaient de tester comment Unity gérait les collisions entre le vaisseau et les objets. La première carte est donc une carte plutôt simpliste. \\

Par soucis d’avoir un environnement dynamique et agréable à jouer, Vincent s’est mis comme objectif de créer une toute nouvelle carte pour le jeu contenant au moins une trentaine de bâtiments texturés dont des objets dynamiques et originaux. Cette carte se passe de nuit et utilise donc une \textit{skybox} sombre. Nous avons choisi la même \textit{skybox} que celle du menu, puisque cette dernière est très bien réalisée.\\

Une centrale nucléaire avec de grosses cheminées recrachant de la vapeur, une centrale hydraulique puisant ses ressources dans une rivière au-dessus de laquelle passent des ponts, des éoliennes dont les pales tournent, des tunnels empruntables pour les vaisseaux et d’autres bâtiments tout aussi originaux ont été ajoutés sur cette nouvelle carte qui a vu le jour entre la seconde et la troisième soutenance. Bien entendu, toutes ces modélisations ont été créées par le graphiste du groupe et texturées par ses soins. Après réflexion, nous nous sommes dit qu'il fallait qu’elles aient toutes une texture pour un environnement de nuit et une texture pour le jour. Ainsi, nous avons pu créer deux cartes identiques de jour et de nuit et ainsi laisser le choix au joueur de jouer de nuit ou de jour.\\

Lors de la création des éoliennes, la question de l'animation se posait. Fallait-il d'abord créer un objet animé dans Blender, puis le rajouter directement dans Unity, ou bien créer deux objets différents; un pour le mât et l'autre pour les pales. Nous avons finalement opté pour la deuxième solution. La rotation de l'objet contenant les pales a été rajoutée au code source afin d'avoir un rendu dynamique.


\newpage
\section{Interfaces utilisateur}

\subsection{Le menu principal}

Tout jeux possède un menu, afin de choisir le mode de jeu, si on veut jouer seul ou à plusieurs, pour modifier les options de son, de graphisme ou autre. Unity possède de nombreuses aides pour faire un menu décent, le tout principalement stocké dans la classe GUI (pour \textit{Graphical User Interface}). Ainsi, la fonction \textit{GUI.Button()} crée un bouton qui prend en paramètre le rectangle de sa localisation et ce qu'il contient, soit du texte ou une image. Cette fonction est mis dans une condition, ce qui fait que dès que le joueur clique sur le bouton, on rentre dans la condition et le programme fait les instructions qui suivent.\\

Cet exemple permet de montrer basiquement comment Unity gère ses interfaces. Il y a aussi des instructions pour afficher du texte (\textit{GUI.Label}), d'autres pour faire des curseurs que l'on utilise pour le son (\textit{HorizontalSlider()} ou \textit{VerticalSlider()}) et d'autres que nous n'avons pas utilisées.\\

En fonction de ses choix dans le menu, le joueur provoque donc l'ouverture de différentes scènes en fonction du mode de jeu qu'il veut. En effet, les modes de jeu sont dans différentes scènes pour faciliter la lecture des scripts. Mais dans le menu des options, le joueur peut aussi modifier les paramètres de la qualité de l'image, du volume du son et peut changer ses touches de contrôle.\\

Ces paramètres sont sauvegardés par le jeu et ne se réinitialise pas lorsque l'on redémarre le jeu par la suite. Cela est rendu possible grâce à la classe \textit{PlayerPrefs()} de Unity. En effet, cette classe permet de sauvegarder des entier (volume), des chaines de caractères (contrôles) et des flottants (nous n'utilisons pas cette dernière option dans ce projet). On charge ainsi les données de ses sauvegarde au démarrage du jeu pour que le joueur garde ses paramètres habituelles. Cette classe nous permet aussi de sauvegarder le vaisseau qu'a choisi le joueur de la scène du menu à la scène de la carte. Ainsi, quand la partie commence, le jeu regarde quelle valeur est sauvegardée pour attribuer au joueur le vaisseau correspondant, ceux-ci étant conservés au préalable dans des prefab.\\

 Nous avons remarqué que lors de l'exportation des modèles depuis Blender vers Unity, la rotation de l'objet était modifiée ce qui faisait que l'on voyait le dessous du vaisseau 2 et le côté du vaisseau 3. Nous avons alors recherché sur internet pour voir que lors de l'exportation en format fbx sur Blender, il fallait choisir les axes pour définir l'avant et le haut de l'objet. Ainsi tout se remettait à l'endroit et le vaisseau était vu correctement et on pouvait le piloter normalement.\\

\subsection{Menu pause}

Arthur a aussi fait le menu pause du jeu. Celui-ci arrête le temps dans le jeu tant que le joueur est dedans, en mettant la valeur \textit{Time.timeScale} à zéro. Ce menu permet de retourner dans les menus si on veut changer ses paramètres ou de mode de jeu, en chargeant les scènes correspondantes. On peut aussi quitter définitivement le jeu pour retourner sur Windows.

\newpage
\section{Intelligences artificielles}

Dans notre jeu, nous voulions que le joueur puisse jouer seul face à d'autres vaisseaux pilotés par l'ordinateur. Il fallait donc créer une intelligence artificielle, c'est-à-dire un programme qui, en fonction de la situation, va changer de comportement pour donner l'illusion que l'on joue contre un vrai joueur. Nous avons fait ce programme en deux parties : l'algorithme pour éviter les obstacles que l'on a présenté pour la deuxième soutenance, et l'algorithme pour suivre les ennemis que nous avons fait après.\\

\subsection{Éviter les obstacles}

Arthur s'est occupé de faire l'intelligence artificielle. Dans un premier temps, nous voulions faire un  algorithme de \textit{pathfiding}. C'est un algorithme qui permet de calculer la trajectoire la plus courte d'un point A à un point B en évitant les obstacles, et donc permet à une intelligence artificielle de se déplacer facilement.\\

Nous avons alors recherché des éléments qui seraient intégrés à Unity pour faire ce genre de programme. Nous avons ainsi découvert les \textit{NavMesh} qui permettent de définir une surface sur laquelle un personnage géré une intelligence artificielle peut se déplacer. Cependant, ils étaient inutiles dans notre jeu, car les vaisseaux ne se déplace pas sur une surface comme le ferait un personnage de jeu de rôle, mais dans l'espace. Il semble qu'il n'existe pas d'aide pour faire de la recherche de trajectoire dans Unity qui intègre aussi la troisième dimension qu'est la hauteur. Nous avons donc commencé à le faire nous-même.\\

Il existe des algorithmes de \textit{pathfiding} qui reposent sur des tableaux contenant le terrain en disant si le personnage peut passer dans telle ou telle case. Cependant c'est assez compliqué à faire en 3D, sans parler du fait que les bâtiments ne sont pas alignés, peuvent être pivotés et qu'il faudrait refaire un tableau pour chaque carte. Nous avons donc essayé de faire autrement.\\

Nous voulions éviter les collisions entre les vaisseaux et les immeubles ou le sol. Nous avons donc placé à l'avant des vaisseaux pilotés par l'ordinateur des objets invisibles qui servent à détecter les collisions que rencontrera le vaisseau s'il ne les évite pas. Ils contiennent des \textit{trigger} qui, dès qu'ils rentrent en collisions, le signal au vaisseau qui ralentit et tourne en conséquence. Il y a 4 objets : un en haut, un en bas, un à gauche et un à droite, tous avancés par rapport au vaisseau. De manière logique, si l'objet en haut détecte une collision, le vaisseau pivote vers le bas, si c'est celui du bas, le vaisseau monte, si c'est l'objet droit qui rencontre un obstacle, le vaisseau tourne à gauche, si c'est le gauche, le vaisseau va à droite.\\

Nous avons remarqué que les collisions n'étaient pas détectées pour les objets qui avait pour collider un Mesh Collider. Nous avons  donc rajouté des Box Collider à tous les bâtiments pour qu’il ne fonce pas dedans, tout en veillant à ce qu'il ne crée  pas de collision avec les autres vaisseaux. Le vaisseau peut ainsi slalomer entre les immeubles sans les percuter, mais il ne cherche pas à attaquer les autres vaisseaux.\\

\subsection{Poursuivre les ennemis}

Dès le début de la partie, les vaisseaux qui ont une intelligence artificielle contiennent les informations de tous les autres vaisseaux, de sorte à savoir à tout moment leur localisation. Grâce à la géométrie dans l'espace, on calcule des équations de plan par rapport au vaisseau, de sorte à le découper sur les trois axes. Ainsi, grâce à ses équations et aux coordonnées des vaisseaux ennemis, on peut savoir de quel côté du plan ces vaisseaux se trouvent. Ainsi, on peut savoir à tout moment si un vaisseau est derrière ou devant, s'il est à gauche ou à droite, et enfin s'il est au-dessus ou en dessous. En fonction de ces résultat, le vaisseau va donc poursuivre de préférence un vaisseau qui est devant lui et tournera pour le suivre. Cependant, l'algorithme fait pour éviter les obstacles décrit précédemment est prioritaire, car le principal, avant d'attaquer les adversaires, est de ne pas rentrer dans tous les gratte-ciels qui passent.

\newpage
\section{Multijoueurs}

Dans notre jeu, nous voulions absolument qu'il y ait du multijoueur, car le jeu serait ennuyeux si on ne pouvait jouer que contre des ordinateurs. En effet pour un jeu de combat aérien en arène fermée, il fallait pouvoir jouer avec ou contre des amis. Nous avons implémenté deux sortes de multijoueur différents : le multijoueur en écran séparé, et le multijoueur en réseau local.\\

\subsection{Multijoueur en écran séparé}

\subsection{Multijoueur en réseau}

Le multijoueur en réseau LAN (pour Local Area Network) fut commencé après la première soutenance. Le but était de pouvoir jouer à plusieurs sur plusieurs ordinateurs différents reliés par un réseau local. L'avantage de ce mode de multijoueur par rapport à l'écran séparé est que le joueur a tout l'écran pour lui et donc peut mieux voir le jeu, et il n'y a pas de problème de répartition de touches de commandes pour les deux joueurs sur le clavier. C'est Arthur qui s'est occupé de cette partie.\\

Il a d'abord essayé de faire un protocole UDP pour relier en LAN (Local Area Network) en s'inspirant du TP que nous avions fait dans les cours d'Informatique Pratique lorsque nous avions travaillé sur le protocole TCP, avant de se rendre compte qu'il existait la classe \textit{Network} sur Unity qui simplifie grandement l'élaboration d'un mode multijoueur sur un jeu. Plusieurs tutoriels existent à ce sujet sur internet, Arthur s'en est donc inspiré pour faire un réseau.\\

Un des joueurs héberge la partie, et les autres doivent le rejoindre en utilisant son adresse IP locale. Il y a donc classiquement un serveur et plusieurs client, le serveur étant l'hébergeur et les client les joueurs rejoignant la partie. A travers le réseau, il fallait envoyer les données des vaisseaux, leurs déplacements, s'ils tiraient et autre. Les coordonnées vaisseaux sont transmises grâce à l'option \textit{Network view} que l'on peut affecter à un objet. Ainsi, lorsqu'un joueur se connecte à une partie, il crée un vaisseau que lui seul peut contrôler, qui contient un \textit{Network view} pour que tout le monde puisse le voir. Par la suite, tous les jeux différents gèrent de leur côté les tirs et les collisions, afin de ne pas encombrer le réseau, mais le résultat est le même pour tous les joueurs. Nous avons donc recréé les prefab de chaque vaisseau car les scripts de déplacement changeait.\\

L'un des problèmes qui se posa au début, fut que les joueurs ne contrôlaient le vaisseau de l'autre joueur et donc devait regarder sur l'autre écran pour jouer. De plus, à trois joueurs, les deux
premiers connectés voyaient un seul et même vaisseau qu'il contrôlaient tous les deux pendant que le troisième joueur en pilotait un autre. Le dernier vaisseau quant à lui n'était contrôlé par personne et restait immobile. Au final, ce problème venait de l'assignation des caméras et des scripts aux joueurs lorsqu'ils instanciaient un nouveau vaisseau en arrivant.\\

Un autre problème fut que nous n'arrivions pas à faire disparaitre le vaisseau d'un joueur lorsqu'il se déconnectait de la partie en ligne. En effet la fonction \textit{Network.Destroy()} ne s'appliquait pas au prefab tout entier car il ne contenait pas de networkView. Finalement, nous avons intégré cette fonction dans les scripts qui contrôle les déplacements du vaisseau et de la caméra.\\

Lorsque l'on démarre le mode réseau, l'antivirus des ordinateurs peut bloquer le jeu, ou tout au moins demander l'autorisation à l'utilisateur de laisser libre la connexion. Cela n'est pas une très grande gêne car une fois que l'on désactive les pare-feu, tout revient dans l'ordre, mais nous ne pouvons pas remédier à ce problème définitivement. Cela ne nous empêche cependant pas de jouer.\\

\newpage
\section{Site internet}

Vincent s'est occupé de la création du site internet officiel du jeu. Il a décidé de créer le site en langage \textit{HTML} par le biais des logiciels d'Adobe, Photoshop et Dreamweaver. Ce dernier est un logiciel permettant de modifier à la fois le code du site directement et de s'occuper de son côté graphique plus aisément.\\

Nous avons voulu créer un site avec un design sombre qui rappellerait un ciel étoilé. De nombreuses images des vaisseaux du jeu sont présentes sur les pages du site afin de le rendre attirant. Les pages du site ont été dessinées sur Photoshop avec des images originales créés spécialement pour le fond d'écran et pour embellir les pages du site.\\

Toutes les pages du site sont traduites en anglais et en français. Il suffit tout simplement de cliquer sur le drapeau correspondant à la langue voulue. Le site contient une page d'accueil, une page pour présenter le jeu et qui fait un tour d’horizon très rapide de ce dernier, une page pour présenter l'équipe et une page où les visiteurs ont accès aux différents fichiers du jeu. Cette dernière page donne accès au cahier des charges, aux rapports des différentes soutenances et au fichier exécutable du jeu.\\


\newpage
\section*{Conclusions}
\addcontentsline{toc}{section}{Conclusion}

\subsection{Conclusions personnelles}

\subsubsection{Conclusion d'Arthur}

\subsection{Conclusion finale}

Ce projet que nous avons réalisé tout au long du second semestre nous a apporté beaucoup de choses, notamment des connaissances des logiciels utilisés comme Unity, Blender\dots Mais au-delà de l'aspect technique, cela nous a appris à travailler en équipe, à gérer les emplois du temps, à savoir répartir le travail aux différents membres du groupe en fonction de leurs compétences, etc\dots

\section{Annexes}

\end{spacing}
\end{document}